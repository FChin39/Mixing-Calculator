"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const helper_plugin_utils_1 = require("@babel/helper-plugin-utils");
const t = __importStar(require("@babel/types"));
const lodash_1 = require("lodash");
const build_store_1 = __importDefault(require("@remax/build-store"));
const shared_1 = require("@remax/shared");
function hostComponent(options) {
    return helper_plugin_utils_1.declare((api) => {
        api.assertVersion(7);
        function shouldRegisterProp(propName, isNative, hostComponent) {
            var _a;
            // key 属性
            if (propName === 'key') {
                return true;
            }
            if (options.includeProps.includes(propName)) {
                return true;
            }
            // 原生组件的属性都要注册
            if (isNative) {
                return true;
            }
            // host component 上的标准属性
            if ((_a = hostComponent === null || hostComponent === void 0 ? void 0 : hostComponent.alias) === null || _a === void 0 ? void 0 : _a[propName]) {
                return true;
            }
            const prefix = `${options.target}-`;
            // 平台特定属性
            if (propName.startsWith(prefix)) {
                return true;
            }
            // data 属性
            if (propName.startsWith('data-')) {
                return true;
            }
            return false;
        }
        function aliasProp(propName, hostComponent) {
            var _a;
            const prefix = `${options.target}-`;
            if (propName.startsWith(prefix)) {
                return propName.replace(new RegExp(`^${prefix}`), '');
            }
            return ((_a = hostComponent === null || hostComponent === void 0 ? void 0 : hostComponent.alias) === null || _a === void 0 ? void 0 : _a[propName]) || propName;
        }
        function registerSlotViewProps(node) {
            let props = [];
            node.openingElement.attributes.forEach(attr => {
                var _a;
                if (t.isJSXSpreadAttribute(attr)) {
                    props = [...props, ...(((_a = options.hostComponents.get('view')) === null || _a === void 0 ? void 0 : _a.props) || [])];
                    return;
                }
                const prop = attr.name;
                let propName = '';
                if (t.isJSXIdentifier(prop)) {
                    propName = prop.name;
                }
                if (t.isJSXNamespacedName(prop)) {
                    return;
                }
                props.push(propName);
            });
            return (props
                // 无需收集 slot 字段
                .filter(p => p !== 'slot')
                .map(prop => aliasProp(prop, options.hostComponents.get('view')))
                .sort());
        }
        function isSlotView(componentName, node) {
            if (!node || componentName !== 'view') {
                return false;
            }
            if (node.openingElement.attributes.find(attr => t.isJSXAttribute(attr) && attr.name.name === 'slot')) {
                return true;
            }
            return false;
        }
        function getProps(id, node, isNative) {
            const hostComponent = options.hostComponents.get(id);
            if (!isNative && !hostComponent) {
                return;
            }
            const props = hostComponent ? hostComponent.props.slice() : [];
            if (node) {
                node.openingElement.attributes.forEach(attr => {
                    if (t.isJSXSpreadAttribute(attr)) {
                        return;
                    }
                    const prop = attr.name;
                    let propName = '';
                    if (t.isJSXIdentifier(prop)) {
                        propName = prop.name;
                    }
                    if (t.isJSXNamespacedName(prop)) {
                        propName = prop.namespace.name + ':' + prop.name.name;
                    }
                    /**
                     * React 运行时读不到 key
                     * 所以在这里如果发现组件上设置了 key
                     * 就再设置一个别名 __key
                     * 然后在模板里写死 key="{{item.props.__key}}"
                     */
                    if (propName === 'key') {
                        node.openingElement.attributes.push(t.jsxAttribute(t.jsxIdentifier('__key'), attr.value));
                    }
                    if (!shouldRegisterProp(propName, !!isNative, hostComponent)) {
                        return;
                    }
                    props.push(propName);
                });
            }
            if (isNative) {
                return Array.from(new Set(props
                    // 剔除 ref，在 axml 特殊处理
                    .filter(p => p !== 'ref')
                    .filter(Boolean)
                    .map(prop => prop.replace('className', 'class')))).sort();
            }
            return Array.from(new Set(props
                // 静态编译辅助字段
                .filter(p => !options.skipProps.includes(p))
                .filter(Boolean)
                .map(prop => aliasProp(prop, hostComponent)))).sort();
        }
        function getHostComponentName(path) {
            const node = path.node;
            const openingElement = node.openingElement;
            if (!t.isJSXIdentifier(openingElement.name)) {
                return;
            }
            const name = openingElement.name.name;
            const binding = path.scope.getBinding(name);
            if (!binding) {
                return;
            }
            const bindingPath = binding.path;
            // binding
            if (!bindingPath || !t.isImportSpecifier(bindingPath.node)) {
                return;
            }
            const importPath = bindingPath.parentPath;
            if (t.isImportDeclaration(importPath) && t.isIdentifier(bindingPath.node.imported)) {
                return lodash_1.kebabCase(bindingPath.node.imported.name);
            }
            return;
        }
        function registerHostComponentManifest(id, node) {
            if (options.skipHostComponents.includes(id)) {
                return;
            }
            let props = [];
            if (isSlotView(id, node)) {
                // isSlotView 确保了 node 一定存在
                props = registerSlotViewProps(node);
                build_store_1.default.slotView.props = Array.from(new Set([...build_store_1.default.slotView.props, ...props]));
                return;
            }
            else {
                props = getProps(id, node);
            }
            if (!props) {
                return;
            }
            const component = {
                id,
                props,
            };
            const registeredComponent = build_store_1.default.collectedComponents.get(id);
            if (registeredComponent) {
                component.props = Array.from(new Set([...props, ...registeredComponent.props])).sort();
            }
            build_store_1.default.collectedComponents.set(id, component);
        }
        function collectCompositionComponents(path, importer) {
            const node = path.node;
            const openingElement = node.openingElement;
            if (!t.isJSXIdentifier(openingElement.name)) {
                return false;
            }
            const name = openingElement.name.name;
            const binding = path.scope.getBinding(name);
            if (!binding) {
                return false;
            }
            const bindingPath = binding.path;
            // binding
            if (!bindingPath) {
                return false;
            }
            const importPath = bindingPath.parentPath;
            if (t.isImportDeclaration(importPath)) {
                const importNode = importPath.node;
                const source = importNode.source.value;
                const props = getProps('', node, true) || [];
                const modules = build_store_1.default.compositionComponents.get(importer) || new Map();
                const component = modules.get(source) || {
                    import: source,
                    props: new Set(props),
                };
                modules.set(source, {
                    import: source,
                    props: new Set([...component.props, ...props]),
                });
                build_store_1.default.compositionComponents.set(importer, modules);
            }
            if (t.isVariableDeclarator(bindingPath.node) &&
                t.isCallExpression(bindingPath.node.init) &&
                t.isIdentifier(bindingPath.node.init.callee) &&
                bindingPath.node.init.callee.name === 'createNativeComponent') {
                const arg0 = bindingPath.node.init.arguments[0];
                if (t.isStringLiteral(arg0)) {
                    const id = arg0.value;
                    // macro 先执行，肯定注册过了
                    const component = Array.from(build_store_1.default.pluginComponents.values()).find(c => c.id === id);
                    const props = getProps('', node, true) || [];
                    props.forEach(component.props.add, component.props);
                }
            }
        }
        return {
            visitor: {
                JSXElement: (path, state) => {
                    const hostComponentName = getHostComponentName(path);
                    if (hostComponentName) {
                        registerHostComponentManifest(hostComponentName, path.node);
                        return;
                    }
                    collectCompositionComponents(path, shared_1.slash(state.file.opts.filename));
                },
                CallExpression: {
                    enter: (path, state) => {
                        var _a, _b;
                        const importer = shared_1.slash(state.file.opts.filename);
                        if (!t.isMemberExpression((_a = path === null || path === void 0 ? void 0 : path.node) === null || _a === void 0 ? void 0 : _a.callee))
                            return;
                        const memberExpression = (_b = path === null || path === void 0 ? void 0 : path.node) === null || _b === void 0 ? void 0 : _b.callee;
                        if (!t.isIdentifier(memberExpression === null || memberExpression === void 0 ? void 0 : memberExpression.property))
                            return;
                        const name = memberExpression === null || memberExpression === void 0 ? void 0 : memberExpression.property.name;
                        if (name !== 'createElement')
                            return;
                        const elementName = path.node.arguments[0];
                        if (!t.isIdentifier(elementName))
                            return;
                        const binding = path.scope.getBinding(elementName.name);
                        if (!binding) {
                            return false;
                        }
                        const bindingPath = binding.path;
                        // binding
                        if (!bindingPath) {
                            return false;
                        }
                        const importPath = bindingPath.parentPath;
                        if (t.isImportDeclaration(importPath)) {
                            const importNode = importPath.node;
                            const source = importNode.source.value;
                            if (source === 'remax')
                                return;
                            const propsObject = path.node.arguments[1];
                            let props = [];
                            if (t.isObjectExpression(propsObject)) {
                                props = propsObject.properties
                                    .map(it => {
                                    if (!t.isObjectProperty(it))
                                        return;
                                    if (t.isIdentifier(it.key))
                                        return it.key.name;
                                    if (t.isStringLiteral(it.key))
                                        return it.key.value;
                                })
                                    .filter(p => p !== 'ref')
                                    .filter(Boolean);
                            }
                            const modules = build_store_1.default.compositionComponents.get(importer) || new Map();
                            const component = modules.get(source) || {
                                import: source,
                                props: new Set(props),
                            };
                            modules.set(source, {
                                import: source,
                                props: new Set([...component.props, ...props]),
                            });
                            build_store_1.default.compositionComponents.set(importer, modules);
                        }
                    },
                },
            },
        };
    });
}
exports.default = hostComponent;
