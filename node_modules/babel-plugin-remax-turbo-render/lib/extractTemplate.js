"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const helper_plugin_utils_1 = require("@babel/helper-plugin-utils");
const t = __importStar(require("@babel/types"));
const build_store_1 = __importDefault(require("@remax/build-store"));
const constants_1 = require("./constants");
const templates_1 = require("./templates");
const helpers = __importStar(require("./helpers"));
function isSlotElement(node) {
    if (t.isJSXElement(node) &&
        node.openingElement.attributes.some((attr) => attr.name && attr.name.name === 'slot')) {
        return true;
    }
    return false;
}
function canExtract(node) {
    const a = t.isJSXElement(node) &&
        !helpers.hasSpreadAttribute(node) &&
        !helpers.hasChildrenAttribute(node) &&
        !isSlotElement(node);
    return a;
}
/**
 * 判断 JSX 元素是否处于一段 JSX 片段的顶部
 * 用于标记 template id
 */
function isRootPath(path, options) {
    const { parent, parentPath, node } = path;
    // 元素自身是非 host component 或者是 block，不能识别为 Root
    if (t.isJSXElement(node) &&
        (node.openingElement.name.name === 'block' ||
            !helpers.isHostComponentElement(node, path, options))) {
        return false;
    }
    // case:
    // 记录根节点
    // 父节点不为 JSXElement 或 JSXFragment，说明 path 为根节点
    if (!t.isJSXElement(parent) && !t.isJSXFragment(parent)) {
        return true;
    }
    // case:
    // parent 本身是一个非 host 组件(React 组件, 原生组件或者无法识别的组件等)
    if (!canExtract(parent) || !helpers.isHostComponentElement(parent, parentPath, options)) {
        return true;
    }
    return false;
}
/**
 * 判断是否是入口 JSX 元素
 *
 * @param {t.JSXElement} node
 * @returns
 */
function isEntry(node) {
    if (t.isJSXFragment(node)) {
        return false;
    }
    return !!node.openingElement.attributes.find(attr => t.isJSXAttribute(attr) && attr.name.name === constants_1.ENTRY);
}
/**
 * 标记 template id
 * 在 react 虚拟 dom 上记录 template id，就可以在渲染时找到虚拟节点对应的模板
 *
 * @param {t.JSXOpeningElement} element
 * @returns
 */
function markTemplateID(filename, element) {
    let templateID = helpers.getTemplateID(element);
    if (!templateID) {
        templateID = build_store_1.default.generateTemplateId(filename);
        element.attributes.push(t.jsxAttribute(t.jsxIdentifier(constants_1.TEMPLATE_ID), t.stringLiteral(templateID)));
    }
    return templateID;
}
/**
 * 整理 JSXNodes，主要目的是消化 JSXFragment，得到正确的 Node 结构
 *
 * @param {JSXNode} node
 * @returns {RenderNode[]}
 */
function sortNodes(node) {
    if (t.isJSXFragment(node)) {
        return node.children.reduce((prev, current) => prev.concat(sortNodes(current)), []);
    }
    if (t.isJSXElement(node)) {
        return [
            {
                node,
                children: node.children.reduce((prev, current) => prev.concat(sortNodes(current)), []),
            },
        ];
    }
    // case JSXText
    // case JSXExpressionContainer
    // case JSXSpreadChild
    return [
        {
            node,
            children: [],
        },
    ];
}
/**
 * 将 JSX 片段保存起来，用于生成静态化的原生模板
 *
 * @export
 * @returns
 */
function extractTemplate(options) {
    return helper_plugin_utils_1.declare(() => {
        /**
         * 遍历 JSX 元素，生成所有模板
         *
         * @param {(NodePath<t.JSXElement | t.JSXFragment>)} path
         * @param {*} state
         * @returns
         */
        function renderTemplates(path, state) {
            if (!isRootPath(path, options)) {
                return;
            }
            const nodes = sortNodes(path.node).sort();
            nodes.forEach(node => {
                // case: JSXExpressionContainer 已经都被包裹在 block 里面，entry 中不会有
                // case: JSXFragment 已经被 sortNodes 方法处理掉了，不会出现
                // case: JSXText TODO: 由于 JSXText 无法记录 template id，这里先不处理
                // case: JSXSpreadChild 未知使用场景
                if (!canExtract(node.node)) {
                    return;
                }
                // block 动态模板不应该生成 templateID
                const name = node.node.openingElement.name.name;
                if (name === constants_1.EXPRESSION_BLOCK || constants_1.SKIP_ELEMENTS.includes(name)) {
                    return;
                }
                const module = state.filename;
                const templateID = markTemplateID(module.replace(state.cwd, ''), node.node.openingElement);
                if (build_store_1.default.extractedTemplates.has(templateID)) {
                    return;
                }
                build_store_1.default.extractedTemplates.set(templateID, {
                    id: templateID,
                    template: templates_1.createTemplate(node, path, ['node'], options),
                    module,
                    isEntry: isEntry(path.node),
                });
            });
        }
        return {
            pre(state) {
                for (const [globalId, template] of build_store_1.default.extractedTemplates) {
                    if (template.module === state.opts.filename) {
                        build_store_1.default.extractedTemplates.delete(globalId);
                    }
                }
                build_store_1.default.resetTemplateId();
            },
            visitor: {
                JSXElement: renderTemplates,
                JSXFragment: renderTemplates,
            },
        };
    });
}
exports.default = extractTemplate;
