"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const helpers = __importStar(require("../helpers"));
const attributes_1 = require("./attributes");
const stringPath_1 = __importDefault(require("./stringPath"));
const constants_1 = require("../constants");
/**
 *  创建 JSXElement 对应的模板
 *
 * @export
 * @param {RenderNode} node
 * @param {NodePath} path
 * @param {(Array<string | number>)} dataPath
 * @param {Function} createTemplate
 * @returns
 */
function JSXElement(node, path, dataPath, createTemplate, options) {
    const { node: element, children } = node;
    const attributes = element.openingElement.attributes;
    // JSXMemberExpression 已经被预处理了，这里只有 JSXIdentifier
    let tag = element.openingElement.name.name;
    // case:
    // 非 host 组件
    // 生成为 TPL_DEFAULT 模板，以动态模板方式渲染
    if (!helpers.isHostComponentElement(element, path, options) ||
        constants_1.SKIP_ELEMENTS.includes(tag) ||
        helpers.hasSpreadAttribute(element) ||
        helpers.hasChildrenAttribute(element)) {
        return `<template is="TPL_DEFAULT" data="{{root: ${stringPath_1.default(dataPath)}}}" />\n`;
    }
    // 获取真正的组件名称
    tag = lodash_1.kebabCase(helpers.getHostComponentName(element, path) || tag);
    const isExpressionBlock = tag === constants_1.EXPRESSION_BLOCK;
    // 处理子节点
    let childrenTemplate = '';
    // case:
    // plain text leaf
    // 单节点文本，子节点直接按 plain-text node 处理
    if (helpers.isPlainTextLeaf(element, path, options)) {
        childrenTemplate = `{{ ${stringPath_1.default(dataPath)}.children[0].text }}\n`;
    }
    else {
        // case:
        // 默认情况，遍历子节点
        childrenTemplate = children
            // 剔除空 JSXText 标签
            .filter(child => !helpers.isEmptyText(child.node))
            .map((child, index) => createTemplate(child, path, isExpressionBlock ? dataPath : [...dataPath, 'children', index], options))
            .join('\n');
    }
    // 生成模板
    return `<${tag} ${attributes_1.createAttributesTemplate(tag, stringPath_1.default(dataPath), attributes)}>${childrenTemplate}</${tag}>\n`;
}
exports.default = JSXElement;
